program Sobol_Nikita;

{$APPTYPE CONSOLE}

uses
  SysUtils, DateUtils, windows;

type
  TEmployee = record
    Code: Integer;
    Name: string[50];
    Position: string[30];
    HoursPerDay: Integer;
    ManagerCode: Integer;
  end;

  TProject = record
    ProjectName: string[50];
    Task: string[255];
    EmployeeCode: Integer;
    ManagerCode: Integer;
    IssueDate: TDate;
    Deadline: TDate;
  end;

  PEmployeeNode = ^TEmployeeNode;
  TEmployeeNode = record
    Data: TEmployee;
    Next: PEmployeeNode;
  end;

  PProjectNode = ^TProjectNode;
  TProjectNode = record
    Data: TProject;
    Next: PProjectNode;
  end;


var
  EmployeesHead: PEmployeeNode = nil;
  ProjectsHead: PProjectNode = nil;


procedure ClearScreen;
var
  cursor: COORD;
  r: cardinal;
begin
  r := 300;
  cursor.X := 0;
  cursor.Y := 0;
  FillConsoleOutputCharacter(GetStdHandle(STD_OUTPUT_HANDLE), ' ', 80 * r, cursor, r);
  SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursor);
end;


function ReadDate(Prompt: string = ''): TDateTime;
var
  S: string;
  Date: TDateTime;
  isCorrect: boolean;
begin
  S := '';
  isCorrect := true;
  repeat
    if not isCorrect then
      writeln('Неверный формат. Повтрите: ');
    Write(Prompt, '(ДД.ММ.ГГГГ): ');
    Readln(S);
    isCorrect := false;
  until TryStrToDate(S, Date);
  Result := Date;
end;

//Clear memory

procedure ClearEmployees(var Head: PEmployeeNode);
var
  Current, Temp: PEmployeeNode;
begin
  Current := Head;
  while Current <> nil do
  begin
    Temp := Current;
    Current := Current^.Next;
    Dispose(Temp);
  end;
  Head := nil;
end;

procedure ClearProjects(var Head: PProjectNode);
var
  Current, Temp: PProjectNode;
begin
  Current := Head;
  while Current <> nil do
  begin
    Temp := Current;
    Current := Current^.Next;
    Dispose(Temp);
  end;
  Head := nil;
end;


//Files

procedure LoadData(var EmployeesHead: PEmployeeNode; var ProjectsHead: PProjectNode);
var
  FEmployees: file of TEmployee;
  FProjects: file of TProject;
  Emp: TEmployee;
  Proj: TProject;
  NewNodeEmp: PEmployeeNode;
  NewNodeProj: PProjectNode;
begin
  // Loading employees
  if FileExists('employees.TEmployee') then
  begin
    AssignFile(FEmployees, 'employees.TEmployee');
    Reset(FEmployees);
    while not Eof(FEmployees) do
    begin
      Read(FEmployees, Emp);
      New(NewNodeEmp);
      NewNodeEmp^.Data := Emp;
      NewNodeEmp^.Next := EmployeesHead;
      EmployeesHead := NewNodeEmp;
    end;
    CloseFile(FEmployees);
  end;

  // Loading projects
  if FileExists('projects.TProject') then
  begin
    AssignFile(FProjects, 'projects.TProject');
    Reset(FProjects);
    while not Eof(FProjects) do
    begin
      Read(FProjects, Proj);
      New(NewNodeProj);
      NewNodeProj^.Data := Proj;
      NewNodeProj^.Next := ProjectsHead;
      ProjectsHead := NewNodeProj;
    end;
    CloseFile(FProjects);
  end;
  Writeln('Данные загружены. Нажмите любую клавишу для продолжения...');
  readln;
end;

procedure SaveData(var EmployeesHead: PEmployeeNode; var ProjectsHead: PProjectNode);
var
  CurrentEmp: PEmployeeNode;
  CurrentProj: PProjectNode;
  FEmployees: file of TEmployee;
  FProjects: file of TProject;
begin
  // Save employees
  AssignFile(FEmployees, 'employees.TEmployee');
  Rewrite(FEmployees);
  CurrentEmp := EmployeesHead;
  while CurrentEmp <> nil do
  begin
    Write(FEmployees, CurrentEmp^.Data);
    CurrentEmp := CurrentEmp^.Next;
  end;
  CloseFile(FEmployees);

  // Save projects
  AssignFile(FProjects, 'projects.TProject');
  Rewrite(FProjects);
  CurrentProj := ProjectsHead;
  while CurrentProj <> nil do
  begin
    Write(FProjects, CurrentProj^.Data);
    CurrentProj := CurrentProj^.Next;
  end;
  CloseFile(FProjects);
  Writeln('Данные сохранены. Нажмите любую клавишу для продолжения...');
  readln;
end;

// Print data

procedure ViewEmployee(const Employee: PEmployeeNode);
begin
  Writeln('Код: ', Employee^.Data.Code);
  Writeln('ФИО: ', Employee^.Data.Name);
  Writeln('Должность: ', Employee^.Data.Position);
  Writeln('Часов в день: ', Employee^.Data.HoursPerDay);
  Writeln('Код руководителя: ', Employee^.Data.ManagerCode);
end;

procedure ViewEmployees(const EmployeesHead: PEmployeeNode);
var
  Current: PEmployeeNode;
begin
  Current := EmployeesHead;
  while Current <> nil do
  begin
    ViewEmployee(Current);
    Writeln('---------------------');
    Current := Current^.Next;
  end;
end;

procedure ViewProject(const Project: PProjectNode);
begin
    Writeln('Проект: ', Project^.Data.ProjectName);
    Writeln('Задача: ', Project^.Data.Task);
    Writeln('Исполнитель: ', Project^.Data.EmployeeCode);
    Writeln('Руководитель: ', Project^.Data.ManagerCode);
    Writeln('Дата выдачи: ', DateToStr(Project^.Data.IssueDate));
    Writeln('Срок выполнения: ', DateToStr(Project^.Data.Deadline));
end;

procedure ViewProjects(const ProjectsHead: PProjectNode);
var
  Current: PProjectNode;
begin
  Current := ProjectsHead;
  while Current <> nil do
  begin
    ViewProject(Current);
    Writeln('---------------------');
    Current := Current^.Next;
  end;
end;

// Add data

procedure AddEmployee(var EmployeesHead: PEmployeeNode);
var
  Emp: TEmployee;
  NewNode: PEmployeeNode;
begin
  Writeln('Добавление сотрудника:');
  Write('Код: '); Readln(Emp.Code);
  Write('ФИО: '); Readln(Emp.Name);
  Write('Должность: '); Readln(Emp.Position);
  Write('Часов в день: '); Readln(Emp.HoursPerDay);
  Write('Код руководителя: '); Readln(Emp.ManagerCode);

  New(NewNode);
  NewNode^.Data := Emp;
  NewNode^.Next := EmployeesHead;
  EmployeesHead := NewNode;
end;

procedure AddProject(var ProjectsHead: PProjectNode);
var
  Proj: TProject;
  NewNode: PProjectNode;
begin
  Writeln('Добавление проекта:');
  Write('Название проекта: '); Readln(Proj.ProjectName);
  Write('Задача: '); Readln(Proj.Task);
  Write('Код исполнителя: '); Readln(Proj.EmployeeCode);
  Write('Код руководителя: '); Readln(Proj.ManagerCode);
  Proj.IssueDate := ReadDate('Дата выдачи');
  Proj.Deadline := ReadDate('Срок выполнения');

  New(NewNode);
  NewNode^.Data := Proj;
  NewNode^.Next := ProjectsHead;
  ProjectsHead := NewNode;
end;


// Delete data

procedure DeleteEmployee(var EmployeesHead: PEmployeeNode);
var
  Code: Integer;
  Current, Prev: PEmployeeNode;
  Found: Boolean;
begin
  Write('Введите код сотрудника для удаления: ');
  Readln(Code);

  Current := EmployeesHead;
  Prev := nil;
  Found := False;

  while (not Found) and (Current <> nil) do
  begin
    if Current^.Data.Code = Code then
    begin
      if Prev = nil then
        EmployeesHead := Current^.Next
      else
        Prev^.Next := Current^.Next;

      Dispose(Current);
      Found := True;
    end
    else
    begin
      Prev := Current;
      Current := Current^.Next;
    end;
  end;

  if Found then
    Writeln('Сотрудник удален')
  else
    Writeln('Сотрудник не найден');
  writeln('Нажмите любую  клавишу для продолжения...');
  readln;
end;


// Special func

procedure SpecialFunctions(const ProjectsHead: PProjectNode);
var
  Choice: Integer;
  ProjectName: string[255];
  CurrentDate: TDate;
  CurrentProj: PProjectNode;
  OutputFile: TextFile;
  HasData: Boolean;
  ProjectsEmpty: Boolean;
begin
  ClearScreen;
  Writeln('1. Список задач по проекту');
  Writeln('2. Задачи с ближайшим сроком (месяц)');
  Writeln('3. Назад');
  Write('Выберите функцию: ');
  Readln(Choice);

  if Choice = 1 then
  begin
    ProjectsEmpty := (ProjectsHead = nil);
    if not ProjectsEmpty then
    begin
      Write('Введите название проекта: ');
      Readln(ProjectName);
      AssignFile(OutputFile, 'project_tasks.txt');
      Rewrite(OutputFile);

      HasData := False;
      CurrentProj := ProjectsHead;
      while CurrentProj <> nil do
      begin
        if CurrentProj^.Data.ProjectName = ProjectName then
        begin
          ViewProject(CurrentProj);
          HasData := True;
        end;
        CurrentProj := CurrentProj^.Next;
      end;

      if not HasData then
        Writeln('Проект не найден или не содержит задач');
      CloseFile(OutputFile);
    end
    else
      Writeln('Список проектов пуст!');
  end
  else if Choice = 2 then
  begin
    ProjectsEmpty := (ProjectsHead = nil);
    if not ProjectsEmpty then
    begin
      CurrentDate := Date();
      AssignFile(OutputFile, 'urgent_tasks.txt');
      Rewrite(OutputFile);

      HasData := False;
      CurrentProj := ProjectsHead;
      while CurrentProj <> nil do
      begin
        if DaysBetween(CurrentDate, CurrentProj^.Data.Deadline) <= 30 then
        begin
          ViewProject(CurrentProj);
          HasData := True;
        end;
        CurrentProj := CurrentProj^.Next;
      end;

      if not HasData then
        Writeln('Нет задач с ближайшим сроком');
      CloseFile(OutputFile);
    end
    else
      Writeln('Список проектов пуст!');
  end;

  if (Choice = 1) or (Choice = 2) then
  begin
    Write('Нажмите Enter...');
    Readln;
  end;
end;


// Menu

procedure SubMenu(const Title: string; var Choice: Integer);
begin
  ClearScreen;
  Writeln(Title);
  Writeln('1. Сотрудники');
  Writeln('2. Проекты');
  Writeln('3. Назад');
  Write('Выберите: ');
  Readln(Choice);
end;

procedure ShowMenu(EmployeesHead: PEmployeeNode; ProjectsHead: PProjectNode);
var
  Choice, SubChoice: Integer;
  quit: boolean;
begin
  quit := false;
  repeat
    ClearScreen;
    Writeln('1. Чтение данных');
    Writeln('2. Просмотр данных');
    Writeln('3. Сортировка');
    Writeln('4. Поиск');
    Writeln('5. Добавление');
    Writeln('6. Удаление');
    Writeln('7. Редактирование');
    Writeln('8. Спец. функции');
    Writeln('9. Выход без сохранения');
    Writeln('10. Выход с сохранением');
    Write('Выберите пункт: ');
    Readln(Choice);

    case Choice of
      1: LoadData(EmployeesHead, ProjectsHead);
      2:
        begin
          SubMenu('Просмотр данных', SubChoice);
          case SubChoice of
            1: ViewEmployees(EmployeesHead);
            2: ViewProjects(ProjectsHead);
          end;
          Write('Нажмите Enter...'); Readln;
        end;
      5:
        begin
          SubMenu('Добавление данных', SubChoice);
          case SubChoice of
            1: AddEmployee(EmployeesHead);
            2: AddProject(ProjectsHead);
          end;
        end;
      6: DeleteEmployee(EmployeesHead);
      8:
        begin
          ClearScreen;
          SpecialFunctions(ProjectsHead);
        end;
      9: quit := true;
      10:
        begin
          SaveData(EmployeesHead, ProjectsHead);
          quit := true;
        end;
    end;
  until quit;
end;

begin
    ShowMenu(EmployeesHead, ProjectsHead);
   readln;
end.
